# pickit 実行計画 (3層アーキテクチャ版)

この計画は、`pickit` の実装を複数のPull Request (PR) に分割し、段階的に開発を進めるためのロードマップです。UI層とアプリケーション層を分離するアーキテクチャを採用します。

---

### **PR #1: プロジェクト基盤の構築とGit連携モジュールの作成**
**目的:** プロジェクトの初期設定と、Gitリポジリ情報を取得するための基本的な機能を実装する。(変更なし)
- **タスク:**
    1. `cargo new pickit` でプロジェクトを作成。
    2. `ratatui`, `clap`, `thiserror` などの基本ライブラリを `Cargo.toml` に追加。
    3. `git` モジュールを作成。
    4. リポジリのルートディレクトリを検出する関数を実装 (`git rev-parse --show-toplevel`)。
    5. `cone` モードでチェックアウトされているディレクトリ一覧を取得する関数を実装 (`git sparse-checkout list`)。
    6. リポジリ内の全ディレクトリ一覧を取得する関数を実装 (`git ls-tree -r --name-only -d HEAD`)。
    7. 上記関数に対するユニットテストを作成。

---

### **PR #2: TUIとApp層の骨格構築**
**目的:** TUIの基本的な骨格を構築し、**単体のアプリケーションとして起動して、静的なディレクトリ一覧を表示できる状態にする。**
- **タスク:**
    1. UIから分離された `app` モジュールを作成し、アプリケーションの状態を保持する `App` 構造体を定義。
    2. `App` 構造体に、Gitモジュールを使ってディレクトリツリー情報を読み込む初期化処理を実装。
    3. `main.rs` にTUIの初期化・終了処理、メインループを実装。
    4. `ratatui` を使い、画面を3パネル（ツリー、グリッド、フッター）に分割。
    5. `App` インスタンスから取得したデータを、加工せずに「ツリービュー」に単純なリストとして描画する。
    6. `cargo run` で起動し、UIが表示されることを確認する。

---

### **PR #3: App層のビジネスロジック実装とテスト**
**目的:** アプリケーションのコアとなるビジネスロジックを `App` 層に実装し、ユニットテストで品質を保証する。**このPRではTUIの見た目はほぼ変更しない。**
- **タスク:**
    1. `App` 構造体に、ツリーの状態（カーソル位置、展開状態、変更待ちフラグ）を管理するフィールドを追加。
    2. ユーザー操作を抽象化したメソッドを実装 (`move_cursor`, `toggle_expansion`, `toggle_selection`)。
    3. 選択されたディレクトリの未コミットの変更をチェックし、ロック状態を判定するロジックを実装。
    4. 上記の各ロジックに対するユニットテストを網羅的に作成する。

---

### **PR #4: TUIとApp層の連携（インタラクティブ化）**
**目的:** TUIのイベントを `App` 層に伝え、その結果をUIに反映させることで、アプリケーションを対話的に操作できるようにする。
- **タスク:**
    1. TUIのメインループで、キー入力を `App` のメソッド呼び出しに変換する（例: `KeyCode::Down` -> `app.move_cursor()`)。
    2. `App` 層に、TUIが必要とする情報（描画用のシンボルや色など）をまとめたViewModelを返すゲッターを実装。
    3. ゲッターから取得したViewModelを元に、ツリービューを状態に合わせて描画する（記号、色、展開状態など）。
    4. これでツリービューが完全にインタラクティブになる。

---

### **PR #5: グリッドビューの実装**
**目的:** `App` 層の情報を利用して、グリッドビューを完成させる。
- **タスク:**
    1. `App` 層に、グリッドビュー用の詳細なViewModelを返すゲッターを実装する。
    2. ツリービューでのカーソル移動に追従し、`App` から取得したViewModelを元にグリッドビューを描画する。

---

### **PR #6: 変更適用機能の実装**
**目的:** ユーザーが選択した変更を `git sparse-checkout` コマンドで実際に適用する機能を完成させる。
- **タスク:**
    1. `App` 層に、適用すべき変更内容から `git sparse-checkout set` コマンドを生成し、実行するメソッド (`apply_changes`) を実装。
    2. TUIで `a` (Apply) キーが押されたら、確認プロンプトを表示後、`app.apply_changes()` を呼び出す。
    3. `App` 層でコマンド実行と、その後の状態リフレッシュ処理を行う。
    4. Gitコマンドのエラーは `App` 層でハンドリングし、TUIは受け取ったエラーメッセージを表示する。

---

### **PR #7: 仕上げとCLI引数の対応**
**目的:** アプリケーションを完成させ、ユーザビリティを向上させる。(旧PR#6)
- **タスク:**
    1. `clap` を用いて、`pickit <path>` のようにリポジトリパスを引数で受け取れるようにする。
    2. フッターに表示するキーバインドやヘルプテキストを充実させる。
    3. アプリケーション全体の動作を見直し、細かいUI/UXの調整を行う。

### PR #10: キー操作の改善

**目的:** アプリケーションのキーボードナビゲーションをより直感的で効率的なものにし、ユーザーエクスペリエンスを向上させる。

**タスク:**
1.  **右キー (`Right`) の動作変更:**
    *   現在のノードが閉じている場合、そのノードを展開する。
    *   現在のノードが開いている場合は、何もしない（トグル動作を廃止し、展開専用とする）。
2.  **左キー (`Left`) の動作変更:**
    *   現在のノードが開いている場合、そのノードを収縮する。
    *   現在のノードが閉じている場合、選択を親ノードに移動する（親ノードに移動後、親ノードが閉じている場合はその親ノードも収縮させる）。
3.  **ページアップ/ページダウン (`PgUp`, `PgDown`) の実装:**
    *   `PgUp` キーで、ビューポートを1ページ分上にスクロールし、選択を新しいビューポートの最初の表示可能ノードに移動する。
    *   `PgDown` キーで、ビューポートを1ページ分下にスクロールし、選択を新しいビューポートの最後の表示可能ノードに移動する。
4.  **その他のナビゲーション改善（提案）:**
    *   **ホーム (`Home`) / エンド (`End`) キー:** ツリーの最初のノード/最後のノードに移動。
    *   **上下キー (`Up`, `Down`) の高速化:** Ctrl+Up/Down でツリーのルートノードにジャンプするか、表示されているツリーの端にジャンプする。
    *   **検索 (`/`) 機能:** 現在のツリー内でノードをインクリメンタル検索し、一致するノードにジャンプする機能。
    *   **タブ (`Tab`) / シフトタブ (`Shift+Tab`) :** 次/前のフォーカス可能なUI要素（例: ツリービューからグリッドビューへの移動）にフォーカスを移動。

## 機能追加計画

### PR #8: 手動リフレッシュ機能の実装と自動ファイル監視の削除

**目的:** パフォーマンス向上のため、自動ファイル監視機能を削除し、代わりに `r` キーによる手動リフレッシュ機能を追加する。これにより、ユーザーは必要に応じて明示的に状態を更新できるようになる。

**タスク:**
1.  既存の自動ファイル監視に関連するコード（もしあれば）をすべて削除する。
2.  `App` 層に、アプリケーションの状態を再読み込みし、TUIを再描画するための `refresh` メソッドを実装する。このメソッドは、`git sparse-checkout list` や `git ls-tree` などのコマンドを再実行し、ツリー構造と各ディレクトリの状態を最新の情報に更新する。
3.  TUIのイベントループに `r` キーのハンドリングを追加する。`r` キーが押されたら、`App` の `refresh` メソッドを呼び出し、UIを更新する。
4.  パフォーマンス改善が意図通りに行われたことを確認するための簡単なプロファイリングまたはベンチマークを行う。

---

### **PR #9: 変更適用時のプログレスダイアログ表示**
**目的:** 変更適用時にアプリケーションが一時的に停止しているように見える問題を解消し、ユーザーに進捗状況を視覚的に伝える。
- **タスク:**
    1. `App` 構造体に、変更適用中であることを示す`is_applying_changes: bool`フラグを追加。
    2. `App::apply_changes` メソッド内で、処理開始時に `is_applying_changes` を `true` に設定し、処理完了後（成功・失敗問わず）に `false` に戻す。
    3. `run_app` 関数（TUIレンダリングループ）内で、`app.is_applying_changes` が `true` の場合、メインUIの代わりに「変更を適用中...お待ちください。」というメッセージを表示するシンプルなプログレスダイアログをレンダリングする。
    4. `is_applying_changes` フラグのライフサイクルを検証するユニットテストを追加。

---

### PR #10: 日本語ファイル名対応 (UTF-8)

**目的:** リポジリの設定に関わらず、日本語UTF-8ファイル名を `pickit` が正しく扱えるようにする。これにより、日本語ファイル名を含むプロジェクトでの利用が可能になり、ユーザビリティを向上させる。

**タスク:**
1.  **Gitコマンド実行時のロケール設定の強化:**
    *   `src/git.rs` 内で `std::process::Command` を使用して `git` コマンドを実行する際、環境変数 `LANG` と `LC_ALL` を `C.UTF-8` に設定する。これにより、`git` が常にUTF-8エンコーディングで出力を生成するように強制する。
    *   例: `.env("LANG", "C.UTF-8").env("LC_ALL", "C.UTF-8")` を `Command` ビルダーに追加。
2.  **Git出力のUTF-8デコードの確実化:**
    *   `git` コマンドの標準出力 (`stdout`) および標準エラー出力 (`stderr`) を、常にUTF-8としてデコードする。
    *   `String::from_utf8(bytes).unwrap_or_else(|_| String::from_utf8_lossy(bytes).into_owned())` のようなロジックを使用して、無効なUTF-8シーケンスが含まれていてもアプリケーションがクラッシュしないようにし、可能な限りデコードを試みる。
    *   特に `git ls-tree` や `git sparse-checkout list` などの出力結果を処理する箇所を重点的に見直す。
3.  **Path処理と表示の統一:**
    *   Rustの `Path` および `PathBuf` 型をファイルパスの表現に一貫して使用する。これらの型はOSのネイティブエンコーディングを抽象化し、プラットフォーム間で互換性のあるパス操作を可能にする。
    *   TUIへの表示時には、`Path` を `to_string_lossy()` を介して `String` に変換し、日本語文字が正しく表示されることを確認する。
4.  **テストケースの追加:**
    *   日本語ファイル名とディレクトリ名を含む新しいテスト用Gitリポジリを自動生成するテストスイートを追加する。
    *   `pickit` がこのテストリポジリのツリーを正しく読み込み、表示できること。
    *   日本語ファイル名を持つノードを正しく選択し、`git sparse-checkout set` コマンドがエラーなく実行されること。
    *   変更適用後、日本語ファイルが期待通りにチェックアウトまたはアンチェックアウトされることを検証する。
# 新しいパス処理戦略

## 方針

`pickit` は Git の疎結合チェックアウトを管理するツールであるため、パス処理においては Git のセマンティクスを最優先する。OS ネイティブのパス表現 `PathBuf` は、アプリケーション起動時のリポジトリルート指定および `std::env::set_current_dir` の呼び出しに限定し、それ以外のリポジトリ内部パスの表現には Git の出力形式に合わせた `String` を用いる。これにより `std::os::unix::ffi::OsStringExt` の利用を排除し、Windows を含むクロスプラットフォームでの堅牢な動作を目指す。

## 詳細

1.  **リポジトリ内部パスの内部表現:**
    *   `TreeItem.path`, `App` 構造体内の `sparse_checkout_dirs`, `uncommitted_paths` など、リポジトリ内のファイルやディレクトリを示すパスは、**クオートされた Git の文字列表現**を `String` 型で保持する。
    *   これは `git` コマンドが `core.quotepath=true` 設定で出力する形式（例: `foo\ bar/baz`, `"\343\201\202.txt"`）に準拠する。

2.  **Git コマンドの実行とパスの取得:**
    *   `src/git.rs` 内で `git` コマンドを実行する際、`std::process::Command` に `"-c", "core.quotepath=true"` を追加する。
    *   現在の `git ls-tree -z`, `git diff -z`, `git ls-files -z` の呼び出しを、対応する**非 `--zero` オプションのコマンド**に変更する。これらはパスを改行区切りで出力し、必要に応じてクオートされる。
        *   例: `git ls-tree -z --name-only -d HEAD` → `git ls-tree -r --name-only -d HEAD` (ただし、これだけでは `core.quotepath` が適用されない可能性や、ディレクトリとファイルが混じる問題があるため、適切なコマンド選定が必要)
        *   例: `git diff --name-only -z HEAD` → `git diff --name-only HEAD`
        *   例: `git ls-files -z --others --exclude-standard` → `git ls-files --others --exclude-standard`
    *   `git` コマンドの標準出力 (`stdout`) は `Vec<u8>` として受け取る。これを `String::from_utf8_lossy()` で `String` に変換する。この `String` は、改行区切りでクオートされたパスを含む。
    *   この `String` を改行で分割し、各行を内部のパス表現 (`String`) として格納する。

3.  **リポジトリ内部パスの操作（join, parent, file_name, starts_with など）:**
    *   これらの操作は、内部の**クオートされた `String`** に対して直接行う。
    *   Git の `core.quotepath=true` 出力の仕様上、パス区切り文字の `/` はエスケープされず、表示可能な ASCII 文字として残るため、この `/` を基点とした `String` 操作が可能。
    *   例: `String::rfind('/')` で最後の区切り文字を見つけ、`String::slice` で親パスやファイル名を抽出。
    *   このロジックは `pickit` 内にカスタムで実装する。

4.  **表示（TUI）:**
    *   内部に保持するクオートされた `String` パスを、`git.rs` に存在する `unescape_git_path_string` 関数に通して、人間が読める通常の `String` に変換してから TUI に表示する。これにより、日本語ファイル名なども正しく表示される。

5.  **Git コマンドへの入力（引数として）:**
    *   `git sparse-checkout set` など、内部のパスを `git` コマンドの引数として渡す必要がある場合、内部のクオートされた `String` パスを**そのまま** `std::process::Command::arg()` メソッドに渡す。Git のパーサーがクオートされた文字列を正しく解釈することを期待する。

6.  **`PathBuf` の利用:**
    *   `current_repo_root: PathBuf` は `App` 構造体で `PathBuf` 型として保持する。これは `std::env::set_current_dir` や `std::process::Command::current_dir` に必要であるため。

## PR への影響

この新しいパス処理戦略は、既存のPR計画に以下の変更をもたらす。

*   **PR #1:** `git` モジュール内の Git コマンド呼び出しとその出力処理が大きく変更される。特に `core.quotepath=true` の適用と、`--zero` オプションを使用しないコマンドへの変更が含まれる。`std::os::unix::ffi::OsStringExt` の利用は排除される。
*   **PR #2, #3, #4, #5, #6:** `TreeItem.path` などのパス関連フィールドの型が `PathBuf` から `String` に変更される。パス操作ロジックは `PathBuf` メソッドではなく、カスタムの `String` 操作メソッドに置き換えられる。`App` 内でのパス比較などにも影響する。
*   **PR #10 (日本語ファイル名対応):** このPRで提案されていたロケール設定の強化や UTF-8 デコードの確実化は、新しい戦略（`core.quotepath=true` によるクオート形式の利用と `String::from_utf8_lossy` での変換）によって置き換えられる。パス処理の主要な変更はこの戦略の一部となる。

## 機能追加計画 (再編成)

自動ファイル監視の削除 (旧 PR #8) と変更適用時のプログレスダイアログ表示 (旧 PR #9) は、この戦略の変更とは独立して進められるため、既存の計画を引き継ぐ。

### PR #8: 手動リフレッシュ機能の実装
(旧 PR #8 から名称変更・内容整理)

**目的:** アプリケーションの状態を手動で更新する機能を提供し、パフォーマンスを向上させる。

**タスク:**
1.  既存の自動ファイル監視に関連するコード（もしあれば）をすべて削除する。
2.  `App` 層に、アプリケーションの状態を再読み込みし、TUIを再描画するための `refresh` メソッドを実装する。このメソッドは、`git sparse-checkout list` や `git ls-tree` などのコマンドを再実行し、ツリー構造と各ディレクトリの状態を最新の情報に更新する。
3.  TUIのイベントループに `r` キーのハンドリングを追加する。`r` キーが押されたら、`App` の `refresh` メソッドを呼び出し、UIを更新する。

### PR #9: 変更適用時のプログレスダイアログ表示
(旧 PR #9 から名称変更・内容整理)

**目的:** 変更適用時にユーザーに進捗状況を視覚的に伝え、ユーザーエクスペリエンスを向上させる。

**タスク:**
1.  `App` 構造体に、変更適用中であることを示す`is_applying_changes: bool`フラグを追加。
2.  `App::apply_changes` メソッド内で、処理開始時に `is_applying_changes` を `true` に設定し、処理完了後（成功・失敗問わず）に `false` に戻す。
3.  `run_app` 関数（TUIレンダリングループ）内で、`app.is_applying_changes` が `true` の場合、メインUIの代わりに「変更を適用中...お待ちください。」というメッセージを表示するシンプルなプログレスダイアログをレンダリングする。
4.  `is_applying_changes` フラグのライフサイクルを検証するユニットテストを追加。